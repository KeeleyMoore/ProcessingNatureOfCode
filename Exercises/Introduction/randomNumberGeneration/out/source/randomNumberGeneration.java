/* autogenerated by Processing revision 1276 on 2021-10-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class randomNumberGeneration extends PApplet {



int[] randomCounts;
// StandardDeviation sd;
PaintSplatter ps;
PerlinNoise pn;

 public void setup() {
  /* size commented out by preprocessor */;
  // equalDistributionSetup();
  // sd = new StandardDeviation();
  // sd.setup();
  ps = new PaintSplatter();
  pn = new PerlinNoise();
}

 public void draw() {
  // sd.draw();
  // ps.draw();
  pn.draw();
}

 public void equalDistributionSetup() {
  randomCounts = new int[20];
  print(randomCounts);
}

 public void equalDistribution() {
  background(255);
  
  int index = PApplet.parseInt(random(randomCounts.length));
  randomCounts[index]++;
  
  stroke(0);
  fill(175);
  int w = width / randomCounts.length;
  for (int x = 0; x < randomCounts.length; x++) {
    rect(x * w, height - randomCounts[x], w - 1 , randomCounts[x]);
  }
}
// Exercise I.4
// Consider a simulation of paint splatter drawn as a collection of colored dots.
// Most of the paint clusters around a central location, but some dots do splatter out towards the edges. 
// Can you use a normal distribution of random numbers to generate the locations of the dots? 
// Can you also use a normal distribution of random numbers to generate a color palette?

Random generatorPS;


class PaintSplatter {
  
  PaintSplatter() {
    generatorPS = new Random();
  }
  
   public void setup() {
    /* size commented out by preprocessor */;
  }
  
   public void draw() {
    // Asking for a Gaussian random number. (Note nextGaussian() returns a double and must be converted to float.)
    float numx = (float) generatorPS.nextGaussian();
    float numy = (float) generatorPS.nextGaussian();
    
    // float red = (float) generatorPS.nextGaussian() * 10;
    // float green = (float) generatorPS.nextGaussian() * 10;
    // float blue = (float) generatorPS.nextGaussian() * 10;
    
    float sdx = 60;
    float sdy = 50;
    float meanx = 290;
    float meany = 160;
    
    // Multiply by the standard deviation and add the mean.
    float x = sdx * numx + meanx;
    float y = sdy * numy + meany;
    
    noStroke();
    // fill(255,10);
    // fill(y * red,x * green,(x + y) * blue, 100);
    // fill((y * red) / 2,(x * red) / 2,((x - y) * red) / 2, 100);
    
    fill(y,x,(x + y) / 2, 100);
    ellipse(x,y,16,16);
  }
}
class PerlinNoise {
  float t = 0;
  
  PerlinNoise() {
    
  }
  
  
   public void draw() {
    float n = noise(t);
    println(n);
    // Now,we move forward in time!
    t += 0.001f;
  }
}
Random generatorSD;
// A distribution of values that cluster around an average (referred to as the “mean”) is known as a “normal” distribution. 
// It is also called the Gaussian distribution.
// When you graph the distribution, you get something that looks like the following, informally known as a bell curve

class StandardDeviation {
  
   public void setup() {
    /* size commented out by preprocessor */;
    generatorSD = new Random();
  }
  
   public void draw() {
    // Asking for a Gaussian random number. (Note nextGaussian() returns a double and must be converted to float.)
    float num = (float) generatorSD.nextGaussian();
    float sd = 60;
    float mean = 320;
    
    // Multiply by the standard deviation and add the mean.
    float x = sd * num + mean;
    
    noStroke();
    fill(255,10);
    ellipse(x,180,16,16);
  }
}


  public void settings() { size(640, 360); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "randomNumberGeneration" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
